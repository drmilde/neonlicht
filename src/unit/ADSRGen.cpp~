#include "ADSRGen.h"


ADSRGen::ADSRGen() : ADSRGen("") {
}

ADSRGen::ADSRGen(std::string name) : UGen(name,1) {

  attack = 1.0;
  decay = 1.0;
  sustain = 0.5;
  release = 1.0;
  
  AttackGen = new EGOneStepGen();
  AttackGen->setDuration(attack);
  AttackGen->setStartLevel(0.0);
  AttackGen->setEndLevel(1.0);

  DecayGen = new EGOneStepGen();
  AttackGen->setDuration(decay);
  AttackGen->setStartLevel(1.0);
  AttackGen->setEndLevel(sustain);

  SustainGen = new GatedConstantGen();
  SustainGen->control("amnt1", sustain);
  SustainGen->control("amnt2", 1.0); // send value

  ReleaseGen = new EGOneStepGen();
  AttackGen->setDuration(release);
  AttackGen->setStartLevel(sustain);
  AttackGen->setEndLevel(0.0);

  
  reset();
}

void ADSRGen::control(std::string portName, float value) {
  if (portName == "trigger") {
    isTriggered = true;
  }

  if (portName == "gate") {
    gate = (value >= 1);
  }
}

void ADSRGen::reset() {
  state = IDLE;
  isTriggered = false;
  gate = false;
}

float ADSRGen::tick() {
  // step through the states of the ADSR

  switch (state) {
  case IDLE: { // waiting for trigger
    setOut1(0.0);
    
    if (isTriggered) { // ADSR trigger is set, switch to ATTACK
      isTriggered = false; // process trigger impulse
      state = ATTACK;
      AttackGen->control("trigger", 1.0); // trigger the AttackGen
    }
  }
  case ATTACK: {
    if (!gate) { // key has been released
      state = RELEASE;
    } else {
      
      // process attack interpolation
      setOut1(AttackGen->tick());
      if (AttackGen->finished()) { // ready with attack phase? then switch to DECAY;
	state = DECAY;
	DecayGen->control("trigger", 1.0); // trigger the DecayGen
      }
    }    
    break;
  }
  case DECAY: {
    if (!gate) { // key has been released
      state = RELEASE;
    } else {
      
      // process decay interpolation
      setOut1(DecayGen->tick());
      if (DecayGen->finished()) { // ready with attack phase? then switch to SUSTAIN;
	state = SUSTAIN;
	SustainGen->control("amnt2", 1.0); // send sustain value
      }
      
    }
    break;
  }
  case SUSTAIN: {
    if (!gate) { // key has been released
      state = RELEASE;
    } else {
      // process sustain hold      
      setOut1(SustainGen->tick()); // send out value, as long as ADSR gate is 1 (key is pressed
    }
    break;
  }
  case RELEASE: {
    if (isTriggered) { // key has been pressed again
      state = IDLE;
    } else {
      
      // process release interpolation
      setOut1(ReleaseGen->tick()); // send out values, as long as key is pressed
      if (ReleaseGen->finished()) {
	reset(); // ready for next ADSR cycle
      }
    }
    break;
  }
  }

  return getOut1();
}
